# NWQ-VQE
VQE simulation based on the NWQ-Sim platform
## Dependencies
- [NLOpt](https://github.com/stevengj/nlopt): NWQ-Sim expects the libraries and header files to be in `$HOME/.nlopt` to allow for non-`sudo` installations. This path can be specified when building NLOpt. The installation steps are (in some arbitrary directory):

```
  git clone https://github.com/stevengj/nlopt
  cd nlopt
  mkdir build;cd build
  cmake .. -DCMAKE_INSTALL_LIBDIR=$HOME/.nlopt \
           -DCMAKE_INSTALL_BINDIR=$HOME/.nlopt \
           -DCMAKE_INSTALL_INCLUDEDIR=$HOME/.nlopt \
           -DCMAKE_INSTALL_DATADIR=$HOME/.nlopt \
           -DCMAKE_INSTALL_MANDIR=$HOME/.nlopt 
  make install
```

## Installation/Configuration Directions
After installing NLOpt, build NWQ-Sim as normal (see the [User Manual](doc/user_manual.md)). If `cmake` succeeded in finding the NLOpt directory, the build process will display:
```
-- NLOpt found: TRUE
```
Running `make` from the `build` directory will compile the binary `build/vqe/nwq_vqe`. 

## Running the Example and General Workflow
Running this file will start an example 6 spatial orbital $H_2O$ ground state optimization using the derivative-free COBYLA algorithm. The file [src/example.cpp](src/example.cpp) contains the example code, explained below.

The NWQ-VQE API can be broken into 3 main steps: problem definition, ansatz construction, and solver configuration.
1. **Problem Definition**: We start by specifying the target Hamiltonian. The program expects a sum of Fermionic operators with complex coefficients. [examples/h2O.hamil](examples/h2O.hamil) provides an example generated by `xacc` for Quantum Chemistry ([source](https://github.com/npbauman/DUCC-Hamiltonians/blob/main/H2O/cc-pv5z/single/6/out-xacc)). 
```
  NWQSim::IdxType n_particles = 10; // Set the number of particles
  // Note: path relative to presumed build directory
  std::string hamiltonian_path = "../vqe/examples/h2O.hamil"; //  Effective Hamiltonian file path

  Hamiltonian hamil(hamiltonian_path, n_particles); // Build the Hamiltonian object (used for energy calculation)
```
2. **Ansatz Construction**: For VQE we need a parameterized wavefunction in the form of a quantum ansatz. The NWQ-VQE package supports the UCCSD ansatz with a Jordan-Wigner (JW) Fermion-Qubit mapping. We specify first specify the JW tranformation function, then call the UCCSD ansatz constructor (subclassed from the NWQ-Sim circuit class). Note that NWQ-Sim backends expect circuits to be wrapped by a `std::shared_ptr`. The `Ansatz` class contains the general functionality needed for optimization, while `UCCSD` provides the specific circuit constructor.
```
  Transformer jw_transform = getJordanWignerTransform; // Choose a transformation function

  // Build the ansatz circuit using the Hamiltonian Molecular environment and JW mapping
  //      (shared_ptr used to match baseline NWQ-Sim functionality)
  std::shared_ptr<Ansatz> ansatz = std::make_shared<UCCSD>(hamil.getEnv(), jw_transform, 1);
```

3. **Solver Configuration**: To solve the problem, we pass the ansatz pointer and the Hamiltonian object to a `SV_CPU_VQE` object to run the main optimization loop. Here we use the COBYLA algorithm implemented by NLOpt, see (NLOpt Algorithms)[https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/] for a full list of algorithms. If the algorithm requires a gradient, the SPSA scheme is used to compute the emprical gradient.
```
  // Build the Quantum State object
  NWQSim::VQE::SV_CPU_VQE state(ansatz, // reference to ansatz
                                hamil,  // reference to Hamiltonian
                                nlopt::algorithm::LN_COBYLA, // NLOpt algorithm for optimization
                                callback_function, // Callback function for each energy evaluation
                                0 // Random seed (passed to the SPSA gradient estimator for random perturbations)
                                );
```
The `callback_function` is specified above, and it permits per-iteration logging. Note that this is called on every function evalution, which may occur multiple times per iteration:
```
// Callback function, requires signature (void*) (const std::vector<NWQSim::ValType>&, NWQSim::ValType, NWQSim::IdxType)
double last = 0.0;
void callback_function(const std::vector<NWQSim::ValType>& x, NWQSim::ValType fval, NWQSim::IdxType iteration) {
  double relchange = abs(last) > 1e-6 ? 0.0 : (fval - last) / last;
  std::cout << "Iteration " << iteration << ", fval = " << fval << ", relchange " << relchange << std::endl;
  last = fval;
}
```

With those 3 steps done, all we need to do is specify a starting point (randomized here)
```
  // Random initial parameters (sets to all 0 by default if not provided). Note that the function modifies `parameters` inplace
  std::vector<double> parameters(ansatz->numParams(), 1.0);
  std::uniform_real_distribution<double> dist(0.0, 2 * PI);
  std::mt19937_64 rand_device(342);
  std::generate(parameters.begin(), parameters.end(), [&] () {return dist(rand_device);});

  // Return destination for the function value
  double fval;

  // Start the VQE optimization
  state.optimize(parameters, fval);
  std::cout << "Final Parameters: " << parameters << std::endl;
  std::cout << "Final Energy: " << fval << std::endl;
```
With the given parameters, the example output is:
```
Final Parameters: [3.38321, 3.12406, 0.604382, 6.23878, 3.13498, 1.6731, 5.19951, 1.00041, 3.85333, 4.45068, 5.18236, 1.87307, 6.08033, 3.72354, 6.11622, 5.92692, 6.27671, 3.12758, 0.143945, 0.531499, 2.67651, 4.47741, 6.26275, 5.59402, 6.08819, 4.87106, 3.67601, 2.49373, 4.21423, 0.376157, 2.17098, 1.46454, 0.0594701, 0.914741, 6.1902]
Final Energy: -75.7452
```
The final energy (-75.7452) is about about 0.6 Hartree away from the true ground state (-76.387). 