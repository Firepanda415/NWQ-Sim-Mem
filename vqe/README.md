# NWQ-VQE
VQE simulation based on the NWQ-Sim platform
## Dependencies
- [NLOpt](https://github.com/stevengj/nlopt): To make simplify installation, NLOpt is a git submodule of NWQ-Sim. After cloning `NWQ-Sim`, we need to sync and build `vqe/nlopt` prior to building NWQ-Sim. The installation steps are:

```shell
  git submodule init
  git submodule update
  cd vqe/nlopt
  mkdir build;cd build
  cmake .. -DCMAKE_CXX_COMPILER=/usr/bin/g++ -DCMAKE_C_COMPILER=/usr/bin/gcc 
  make
```
The specific CXX/C compiler paths can be altered as needed, the main emphasis is to ensure that the optimization code has access to C++ STD libraries.

## Installation/Configuration Directions
After installing NLOpt, build NWQ-Sim as normal (see the [User Manual](doc/user_manual.md)).

 Note that debug messages showing the Fermionic operator indices and Hamiltonian Pauli strings will be printed *unless* the project is built in `Release` mode (add `-DCMAKE_BUILD_TYPE=Release`). 

Running `make` from the `build` directory will compile the binary `build/vqe/nwq_vqe`, a shared library `build/vqe/libvqe.dylib`, and the example binaries under `/build/vqe/examples`. 

## Running the Command Line Solver
To test NWQ-VQE from the command line, run the `build/vqe/nwq_vqe` executable. This program takes program parameters and file paths as command line arguments and configures the solver accordingly. The command line options are:
```shell
Usage: NWQ-VQE [--help] [--version] [--hamiltonian VAR] [--nparticles VAR] [--config VAR] [--maxeval VAR] [--seed VAR] [--reltol VAR] [--abstol VAR] [--maxtime VAR] [--stopval VAR] [--optimizer VAR]

Optional arguments:
  -h, --help         shows help message and exits 
  -v, --version      prints version information and exits 
  -f, --hamiltonian  Path to Fermionic Hamiltonian file 
  -n, --nparticles   Number of particles to model 
  -c, --config       Optimizer configuration file [nargs=0..1] [default: ""]
  --maxeval          Maximum number of function evaluations [nargs=0..1] [default: 200]
  --seed             Random seed [nargs=0..1] [default: 1717713962]
  --reltol           Relative function value tolerance cutoff [nargs=0..1] [default: -1]
  --abstol           Absolute function value tolerance cutoff [nargs=0..1] [default: -1]
  --maxtime          Optimizer timeout (seconds) [nargs=0..1] [default: -1]
  --stopval          Optimizer value cutoff [nargs=0..1] [default: -3.40282e+38]
  --optimizer        Optimization algorithm name (NLOpt key, see [NLOpt Algorithms](https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/)) [nargs=0..1] [default: "LN_COBYLA"]
```
`--hamiltonian` and `--nparticles` are the only required arguments.

To specify algorithm-specific settings from the command line (as shown in [examples/config_example.cpp](examples/config_example.cpp)), pass as JSON file with a parameter: value dictionary. For example, passing the following via the `--config` argument with `--optimizer=LD_MMA`:
```json
{
    "inner_maxeval": 6,
    "verbosity": 2,
    "dual_ftol_rel": 1e-12
}
```
specifies a maximum of 6 function evaluations per inner loop iteration, a verbosity level of 2, and a relative tolerance for the dual optimization step of $10^{-12}$.
 

## Running the Example(s) and General Workflow
To add NWQ-VQE functionality:
1. Add the include paths:
  - Makefile: Add the `-I<Path_To_NWQSIM>/vqe/include` flag 
  - CMake: Add `include_directories(BEFORE PRIVATE <path_to_NWQSIM>/vqe/include)` to your CMakeLists.txt file.
2. Link to the shared library:
  - Makefile: Add flags for the library directory `-L<Path_To_NWQSIM>/build/vqe` and library `-lvqe`
  - CMake: Add the following lines to specify the directory and executable dependencies:
  ```cmake
  link_directories(BEFORE PRIVATE <Path_To_NWQSIM>/build/vqe)
  link_libraries(vqe) 
  ```

The file [examples/basic_example.cpp](src/example.cpp) contains basic example code, explained below. The corresponding executable is compiled to `build/vqe/examples/basic_example`. Note that the example code

The NWQ-VQE API can be broken into 3 main steps: problem definition, ansatz construction, and solver configuration.
1. **Problem Definition**: We start by specifying the target Hamiltonian. The program expects a sum of Fermionic operators with complex coefficients. [example_hamiltonians/h2O.hamil](examples/h2O.hamil) provides an example generated by `xacc` for Quantum Chemistry ([source](https://github.com/npbauman/DUCC-Hamiltonians/blob/main/H2O/cc-pv5z/single/6/out-xacc)). 
```c++
  NWQSim::IdxType n_particles = 10; // Set the number of particles
  // Note: path relative to presumed build directory
  std::string hamiltonian_path = "../vqe/example_hamiltonians/h2O.hamil"; //  Effective Hamiltonian file path

  Hamiltonian hamil(hamiltonian_path, n_particles); // Build the Hamiltonian object (used for energy calculation)
```
2. **Ansatz Construction**: For VQE we need a parameterized wavefunction in the form of a quantum ansatz. The NWQ-VQE package supports the UCCSD ansatz with a Jordan-Wigner (JW) Fermion-Qubit mapping. We specify first specify the JW tranformation function, then call the UCCSD ansatz constructor (subclassed from the NWQ-Sim circuit class). Note that NWQ-Sim backends expect circuits to be wrapped by a `std::shared_ptr`. The `Ansatz` class contains the general functionality needed for optimization, while `UCCSD` provides the specific circuit constructor.
```c++
  Transformer jw_transform = getJordanWignerTransform; // Choose a transformation function

  // Build the ansatz circuit using the Hamiltonian Molecular environment and JW mapping
  //      (shared_ptr used to match baseline NWQ-Sim functionality)
  std::shared_ptr<Ansatz> ansatz = std::make_shared<UCCSD>(hamil.getEnv(), jw_transform, 1);
```

3. **Solver Configuration**: To solve the problem, we pass the ansatz pointer and the Hamiltonian object to a `SV_CPU_VQE` object to run the main optimization loop. Here we use the COBYLA algorithm implemented by NLOpt, see (NLOpt Algorithms)[https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/] for a full list of algorithms. If the algorithm requires a gradient, the SPSA scheme is used to compute the emprical gradient.
```c++
  // Build the Quantum State object
  NWQSim::VQE::SV_CPU_VQE state(ansatz, // reference to ansatz
                                hamil,  // reference to Hamiltonian
                                nlopt::algorithm::LN_COBYLA, // NLOpt algorithm for optimization
                                callback_function, // Callback function for each energy evaluation
                                0 // Random seed (passed to the SPSA gradient estimator for random perturbations)
                                );
```
The `callback_function` is specified above, and it permits per-iteration logging. Note that this is called on every function evalution, which may occur multiple times per iteration:
```c++
// Callback function, requires signature (void*) (const std::vector<NWQSim::ValType>&, NWQSim::ValType, NWQSim::IdxType)
double last = 0.0;
void callback_function(const std::vector<NWQSim::ValType>& x, NWQSim::ValType fval, NWQSim::IdxType iteration) {
  double relchange = abs(last) > 1e-6 ? 0.0 : (fval - last) / last;
  std::cout << "Iteration " << iteration << ", fval = " << fval << ", relchange " << relchange << std::endl;
  last = fval;
}
```

With those 3 steps done, all we need to do is specify a starting point (randomized here)
```c++
  // Random initial parameters (sets to all 0 by default if not provided). Note that the function modifies `parameters` inplace
  std::vector<double> parameters(ansatz->numParams(), 1.0);
  std::uniform_real_distribution<double> dist(0.0, 2 * PI);
  std::mt19937_64 rand_device(342);
  std::generate(parameters.begin(), parameters.end(), [&] () {return dist(rand_device);});

  // Return destination for the function value
  double fval;

  // Start the VQE optimization
  state.optimize(parameters, fval);
  std::cout << "Final Parameters: " << parameters << std::endl;
  std::cout << "Final Energy: " << fval << std::endl;
```
With the given parameters, the example output is:
```shell
Final Parameters: [3.38321, 3.12406, 0.604382, 6.23878, 3.13498, 1.6731, 5.19951, 1.00041, 3.85333, 4.45068, 5.18236, 1.87307, 6.08033, 3.72354, 6.11622, 5.92692, 6.27671, 3.12758, 0.143945, 0.531499, 2.67651, 4.47741, 6.26275, 5.59402, 6.08819, 4.87106, 3.67601, 2.49373, 4.21423, 0.376157, 2.17098, 1.46454, 0.0594701, 0.914741, 6.1902]
Final Energy: -75.7452
```
The final energy (-75.7452) is about about 0.6 Hartree away from the true ground state (-76.387). 

The example file [examples/config_example.cpp](examples/config_example.cpp) is similar, but demonstrates how to specify `NLOpt` algorithm parameters and cutoff criteria within NWQ-VQE.

The same example can be run with the command line-configurable `nwq_vqe` executable by running:
```shell
./vqe/nwq_vqe -f ../vqe/example_hamiltonians/h2O.hamil -n 10
```
To run the example CUDA and MPI examples respectively, run (from `NWQ-Sim/build`):
```shell
./vqe/examples/vqe/examples/basic_example_cuda
./vqe/examples/vqe/examples/basic_example_mpi
```